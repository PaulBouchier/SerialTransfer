#pragma once
#include "Arduino.h"
#include "Packet.h"

/*! \file SerialTransfer.hD
    \brief File declaring the SerialTransfer class and implementing some methods
*/

/*! \class SerialTransfer
 * \brief Transport protocol for passing packetized data over a serial link.
 *
 * The SerialTransfer class implements a protocol that transfers packetized data
 * fast and reliably via Serial, I2C, and SPI interfaces. It runs on Arduino,
 * where it interoperates with SerialTransfer on other Arduinos, or with pySerialTransfer
 * on a computer running Python.
 * 
 * The protocol is a UDP-style fire-and-forget datagram transport. It has no
 * concept of a session or retry-on-error. Higher-level design must account for
 * the fact that packets with errors will be dropped.
 * 
 * The protocol supports a packetID, which can be used as a packet type identifier.
 * If callbacks are used, the specific callback function called upon packet receipt
 * is selected by the packetID. This enables message type-specific selection of the
 * callback function.
 * 
 * See README.md for a full list of features. This documentation provides for autogenerated
 * API documentation.
 */
class SerialTransfer
{
  public: // <<---------------------------------------//public
	//! \brief Class instance for low-level packet parsing and handling
	Packet  packet;

	/*!
	\bug Class members bytesRead and status are not valid during callbacks, and are duplicates of the
	corresponding variables in class packet. They should be removed, and packet variables
	should be recommended for use by clients of this class instead.
	*/

	//! \brief Number of bytes read during call to available().
	//!
	//! Not valid during a callback - use 
	//! packet.bytesRead instead.
	uint8_t bytesRead = 0;

	//! \brief Packet fsm state. See packet class documentation for values.
	//!
	//! Not valid during a callback - use packet.status instead
	int8_t  status    = 0;


	/*
	 * NOTE Documentation for the undocumented method declarations below is in SerialTransfer.cpp
	 */
	void    begin(Stream& _port, const configST configs);
	void    begin(Stream& _port, const bool _debug = true, Stream& _debugPort = Serial, uint32_t _timeout = DEFAULT_TIMEOUT);
	uint8_t sendData(const uint16_t& messageLen, const uint8_t packetID = 0);
	uint8_t available();
	bool    tick();
	uint8_t currentPacketID();
	void    reset();


	/*! \brief Copy the object "val", passed by reference, into the transmit buffer

	  Copies "len" number of bytes of an arbitrary object (byte, int,
	  float, double, struct, etc...) into the transmit buffer (txBuff)
	  starting at the index as specified by the argument "index".

	  \param [in] val Reference to the object to be copied to the transmit buffer (txBuff)
	  \param [in] index Starting index of the object within the transmit buffer (txBuff). Default: 0
	  \param [in] len Number of bytes of the object "val" to transmit. Default: sizeof(val)
	  \return Index of the transmit buffer (txBuff) byte that directly follows the bytes processed
	  by the calling of this member function. The return is intended to be used as index by
	  the next call to txObj (if one exists).
	*/
	template <typename T>
	uint16_t txObj(const T& val, const uint16_t& index = 0, const uint16_t& len = sizeof(T))
	{
		return packet.txObj(val, index, len);
	}


	/*! \brief Extract received data and place into object "val"

	  Reads "len" number of bytes from the receive buffer (rxBuff)
	  starting at the index as specified by the argument "index"
	  into an arbitrary object (byte, int, float, double, struct, etc...)

	  \param [out] val Reference to the object to be copied into from the receive buffer (rxBuff)
	  \param [in] index Starting index of the object within the receive buffer (rxBuff). Default: 0
	  \param [in] len Number of bytes in the object "val" received. Default: sizeof(val)
	  \return Index of the receive buffer (rxBuff) that directly follows the bytes processed
	  by the calling of this member function. The return is intended to be passed to 
	  a following call to rxObj() as the index parameter.
	*/
	template <typename T>
	uint16_t rxObj(const T& val, const uint16_t& index = 0, const uint16_t& len = sizeof(T))
	{
		return packet.rxObj(val, index, len);
	}


	/*! \brief Put the supplied object into the transmit buffer and send it.

	  Stuffs "len" number of bytes of an arbitrary object (byte, int,
	  float, double, struct, etc...) into the transmit buffer (txBuff)
	  starting at index 0 and immediately transmit the bytes in an individual packet

	  \param [in] val Reference to the object to be copied to the transmit buffer (txBuff)
	  \param [in] len Number of bytes of the object "val" to transmit. Default: sizeof(val)
	  \return Number of payload bytes included in packet
	*/
	template <typename T>
	uint8_t sendDatum(const T& val, const uint16_t& len = sizeof(T))
	{
		return sendData(packet.txObj(val, 0, len));
	}


  private: // <<---------------------------------------//private
	Stream* port;
	uint32_t timeout;
};
